<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3.js Charts - Assignment 3</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
        }
        
        .chart-container {
            background: white;
            margin: 30px auto;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 1000px;
        }
        
        h1 {
            font-size: 28px;
            margin: 0 0 20px 0;
            color: #333;
        }
        
        .axis-label {
            font-size: 14px;
            fill: #666;
        }
        
        .grid-line {
            stroke: #e0e0e0;
            stroke-width: 1;
            shape-rendering: crispEdges;
        }
        
        .legend {
            font-size: 12px;
        }
        
        .tooltip {
            position: absolute;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }
        
        .curve-line {
            fill: none;
            stroke-width: 3;
        }
        
        .area-fill {
            opacity: 0.7;
        }
        
        .optimization-path {
            fill: none;
            stroke: #333;
            stroke-width: 2;
        }
        
        .optimization-point {
            cursor: pointer;
        }
        
        .contour {
            fill: none;
            stroke: #ccc;
            stroke-width: 1;
        }
        
        .tree-node {
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .tree-link {
            fill: none;
            stroke: #5e6c84;
            stroke-width: 2;
        }
        
        .tree-node circle {
            fill: #fff;
            stroke: #5e6c84;
            stroke-width: 2;
        }
        
        .tree-node.selected circle {
            fill: #4a90e2;
            stroke: #2e5c8a;
        }
        
        .tree-node text {
            font-size: 12px;
            fill: #333;
        }
        
        .tree-branch {
            stroke: #8b7355;
            stroke-width: 3;
            fill: none;
        }
        
        .tree-leaf {
            fill: #4caf50;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="chart-container">
        <h1>Chart 1 (vector space)</h1>
        <svg id="chart1"></svg>
    </div>
    
    <div class="chart-container">
        <h1>Chart 11 (function)</h1>
        <svg id="chart11"></svg>
    </div>
    
    <div class="chart-container">
        <h1>Chart 4 (frequency)</h1>
        <svg id="chart4"></svg>
    </div>
    
    <div class="chart-container">
        <h1>Chart 3 (optimisation route)</h1>
        <svg id="chart3"></svg>
    </div>
    
    <div class="chart-container">
        <h1>Chart 9 (sketch)</h1>
        <svg id="chart9"></svg>
    </div>
    
    <div class="tooltip"></div>

    <script>
        const tooltip = d3.select(".tooltip");

        // ============================================
        // CHART 1: VECTOR SPACE
        // ============================================
        function createChart1() {
            const margin = {top: 20, right: 20, bottom: 20, left: 20};
            const width = 900 - margin.left - margin.right;
            const height = 450 - margin.top - margin.bottom;

            const svg = d3.select("#chart1")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create grid
            const gridSize = 50;
            const numCols = Math.ceil(width / gridSize);
            const numRows = Math.ceil(height / gridSize);

            // Draw vertical grid lines with animation
            for (let i = 0; i <= numCols; i++) {
                svg.append("line")
                    .attr("class", "grid-line")
                    .attr("x1", i * gridSize)
                    .attr("y1", 0)
                    .attr("x2", i * gridSize)
                    .attr("y2", height)
                    .attr("opacity", 0)
                    .transition()
                    .duration(500)
                    .delay(i * 20)
                    .attr("opacity", 1);
            }

            // Draw horizontal grid lines with animation
            for (let i = 0; i <= numRows; i++) {
                svg.append("line")
                    .attr("class", "grid-line")
                    .attr("x1", 0)
                    .attr("y1", i * gridSize)
                    .attr("x2", width)
                    .attr("y2", i * gridSize)
                    .attr("opacity", 0)
                    .transition()
                    .duration(500)
                    .delay(i * 20)
                    .attr("opacity", 1);
            }

            // Define vector points
            const vectors = [
                {
                    id: "e1_beta",
                    start: {x: 600, y: 300},
                    end: {x: 600, y: 300},
                    label: "e₁^β",
                    color: "#2c3e50",
                    subscript: "1"
                },
                {
                    id: "e2_beta",
                    start: {x: 350, y: 300},
                    end: {x: 350, y: 300},
                    label: "e₂^β",
                    color: "#2c3e50",
                    subscript: "2"
                },
                {
                    id: "e1_alpha",
                    start: {x: 600, y: 300},
                    end: {x: 800, y: 150},
                    label: "e₁^α",
                    color: "#e74c3c",
                    subscript: "1"
                },
                {
                    id: "e2_alpha",
                    start: {x: 350, y: 300},
                    end: {x: 500, y: 100},
                    label: "e₂^α",
                    color: "#27ae60",
                    subscript: "2"
                }
            ];

            // Create arrow markers
            const defs = svg.append("defs");
            
            ["#e74c3c", "#27ae60", "#2c3e50"].forEach((color, idx) => {
                defs.append("marker")
                    .attr("id", `arrow-${idx}`)
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 8)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", color);
            });

            // Dashed connection lines
            const dashedLine1 = svg.append("path")
                .attr("d", `M ${vectors[0].start.x} ${vectors[0].start.y} L ${vectors[2].end.x} ${vectors[2].end.y}`)
                .attr("stroke", "#4a90e2")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "8, 4")
                .attr("fill", "none")
                .attr("opacity", 0);

            const dashedLine2 = svg.append("path")
                .attr("d", `M ${vectors[1].start.x} ${vectors[1].start.y} L ${vectors[3].end.x} ${vectors[3].end.y}`)
                .attr("stroke", "#4a90e2")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "8, 4")
                .attr("fill", "none")
                .attr("opacity", 0);

            // Function to get marker id based on color
            function getMarkerId(color) {
                if (color === "#e74c3c") return "arrow-0";
                if (color === "#27ae60") return "arrow-1";
                return "arrow-2";
            }

            // Draw vectors with animation
            function drawVector(vector, delay) {
                const group = svg.append("g");
                
                // Draw arrow line
                const line = group.append("line")
                    .attr("x1", vector.start.x)
                    .attr("y1", vector.start.y)
                    .attr("x2", vector.start.x)
                    .attr("y2", vector.start.y)
                    .attr("stroke", vector.color)
                    .attr("stroke-width", 2)
                    .attr("marker-end", `url(#${getMarkerId(vector.color)})`);

                // Animate line growth
                line.transition()
                    .duration(1000)
                    .delay(delay)
                    .attr("x2", vector.end.x)
                    .attr("y2", vector.end.y)
                    .on("end", function() {
                        // Show dashed lines after alpha vectors are drawn
                        if (vector.id === "e1_alpha") {
                            dashedLine1.transition().duration(500).attr("opacity", 1);
                        } else if (vector.id === "e2_alpha") {
                            dashedLine2.transition().duration(500).attr("opacity", 1);
                        }
                    });

                // Add endpoint circle
                const point = group.append("circle")
                    .attr("cx", vector.start.x)
                    .attr("cy", vector.start.y)
                    .attr("r", 0)
                    .attr("fill", vector.color)
                    .attr("class", "optimization-point")
                    .attr("data-id", vector.id);

                point.transition()
                    .duration(1000)
                    .delay(delay)
                    .attr("cx", vector.end.x)
                    .attr("cy", vector.end.y)
                    .attr("r", 6);

                // Add label
                const labelOffset = vector.id.includes("alpha") ? -25 : 35;
                const label = group.append("text")
                    .attr("x", vector.end.x)
                    .attr("y", vector.end.y + labelOffset)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "20px")
                    .attr("font-style", "italic")
                    .attr("opacity", 0)
                    .text(vector.label);

                label.transition()
                    .duration(500)
                    .delay(delay + 1000)
                    .attr("opacity", 1);

                // Add interactivity
                point.on("mouseover", function(event) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("r", 10);
                    
                    // Highlight corresponding dashed line
                    if (vector.id === "e1_alpha") {
                        dashedLine1.transition().duration(200)
                            .attr("stroke-width", 3)
                            .attr("opacity", 1);
                    } else if (vector.id === "e2_alpha") {
                        dashedLine2.transition().duration(200)
                            .attr("stroke-width", 3)
                            .attr("opacity", 1);
                    }
                    
                    tooltip
                        .style("opacity", 1)
                        .html(`<strong>${vector.label}</strong><br/>Click to animate`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 30) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("r", 6);
                    
                    if (vector.id === "e1_alpha") {
                        dashedLine1.transition().duration(200).attr("stroke-width", 2);
                    } else if (vector.id === "e2_alpha") {
                        dashedLine2.transition().duration(200).attr("stroke-width", 2);
                    }
                    
                    tooltip.style("opacity", 0);
                })
                .on("click", function() {
                    // Pulse animation
                    d3.select(this)
                        .transition()
                        .duration(300)
                        .attr("r", 12)
                        .transition()
                        .duration(300)
                        .attr("r", 6);
                    
                    // Animate vector back and forth
                    line.transition()
                        .duration(500)
                        .attr("x2", vector.start.x)
                        .attr("y2", vector.start.y)
                        .transition()
                        .duration(500)
                        .attr("x2", vector.end.x)
                        .attr("y2", vector.end.y);
                    
                    d3.select(this)
                        .transition()
                        .duration(500)
                        .attr("cx", vector.start.x)
                        .attr("cy", vector.start.y)
                        .transition()
                        .duration(500)
                        .attr("cx", vector.end.x)
                        .attr("cy", vector.end.y);
                });
            }

            // Draw all vectors with staggered delays
            vectors.forEach((vector, i) => {
                drawVector(vector, 600 + i * 300);
            });
        }

        // ============================================
        // CHART 11: PROBABILITY DENSITY FUNCTIONS
        // ============================================
        function createChart11() {
            const margin = {top: 40, right: 200, bottom: 60, left: 80};
            const width = 900 - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;

            const svg = d3.select("#chart11")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Generate data for two normal distributions
            const data1 = [], data2 = [];
            const mean1 = -0.5, std1 = 1;
            const mean2 = 1.5, std2 = 1.1;
            
            for (let x = -2.5; x <= 5; x += 0.05) {
                const y1 = (1 / (std1 * Math.sqrt(2 * Math.PI))) * 
                           Math.exp(-0.5 * Math.pow((x - mean1) / std1, 2));
                const y2 = (1 / (std2 * Math.sqrt(2 * Math.PI))) * 
                           Math.exp(-0.5 * Math.pow((x - mean2) / std2, 2));
                data1.push({x, y: y1});
                data2.push({x, y: y2});
            }

            // Scales
            const xScale = d3.scaleLinear()
                .domain([-2.5, 5])
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, 0.35])
                .range([height, 0]);

            // Grid
            svg.append("g")
                .attr("class", "grid")
                .selectAll("line")
                .data(xScale.ticks(15))
                .enter()
                .append("line")
                .attr("class", "grid-line")
                .attr("x1", d => xScale(d))
                .attr("x2", d => xScale(d))
                .attr("y1", 0)
                .attr("y2", height)
                .attr("opacity", 0)
                .transition()
                .duration(800)
                .attr("opacity", 1);

            svg.append("g")
                .attr("class", "grid")
                .selectAll("line.y")
                .data(yScale.ticks(8))
                .enter()
                .append("line")
                .attr("class", "grid-line")
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", d => yScale(d))
                .attr("y2", d => yScale(d))
                .attr("opacity", 0)
                .transition()
                .duration(800)
                .attr("opacity", 1);

            // Overlap area
            const overlapArea = [];
            for (let x = 0; x <= 1; x += 0.05) {
                const y1 = (1 / (std1 * Math.sqrt(2 * Math.PI))) * 
                           Math.exp(-0.5 * Math.pow((x - mean1) / std1, 2));
                const y2 = (1 / (std2 * Math.sqrt(2 * Math.PI))) * 
                           Math.exp(-0.5 * Math.pow((x - mean2) / std2, 2));
                overlapArea.push({x, y: Math.min(y1, y2)});
            }

            const areaGenerator = d3.area()
                .x(d => xScale(d.x))
                .y0(height)
                .y1(d => yScale(d.y))
                .curve(d3.curveBasis);

            // Draw overlap area
            svg.append("path")
                .datum(overlapArea)
                .attr("d", areaGenerator)
                .attr("fill", "#999")
                .attr("opacity", 0)
                .transition()
                .delay(1500)
                .duration(800)
                .attr("opacity", 0.4);

            // Line generator
            const lineGenerator = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .curve(d3.curveBasis);

            // Draw curves
            const path1 = svg.append("path")
                .datum(data1)
                .attr("class", "curve-line")
                .attr("stroke", "#f39c12")
                .attr("d", lineGenerator)
                .attr("stroke-dasharray", function() {
                    return this.getTotalLength();
                })
                .attr("stroke-dashoffset", function() {
                    return this.getTotalLength();
                })
                .transition()
                .duration(2000)
                .attr("stroke-dashoffset", 0);

            const path2 = svg.append("path")
                .datum(data2)
                .attr("class", "curve-line")
                .attr("stroke", "#3498db")
                .attr("d", lineGenerator)
                .attr("stroke-dasharray", function() {
                    return this.getTotalLength();
                })
                .attr("stroke-dashoffset", function() {
                    return this.getTotalLength();
                })
                .transition()
                .delay(500)
                .duration(2000)
                .attr("stroke-dashoffset", 0);

            // Vertical dashed lines
            svg.append("line")
                .attr("x1", xScale(0))
                .attr("x2", xScale(0))
                .attr("y1", yScale(0))
                .attr("y2", yScale(0.25))
                .attr("stroke", "#333")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5")
                .attr("opacity", 0)
                .transition()
                .delay(2200)
                .duration(500)
                .attr("opacity", 0.6);

            svg.append("line")
                .attr("x1", xScale(1))
                .attr("x2", xScale(1))
                .attr("y1", yScale(0))
                .attr("y2", yScale(0.25))
                .attr("stroke", "#333")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5")
                .attr("opacity", 0)
                .transition()
                .delay(2200)
                .duration(500)
                .attr("opacity", 0.6);

            // Axes
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
                .style("font-size", "12px");

            svg.append("g")
                .call(d3.axisLeft(yScale).ticks(7).tickFormat(d3.format(".2f")))
                .style("font-size", "12px");

            // Labels
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + 45)
                .text("x");

            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", `translate(-50,${height/2})rotate(-90)`)
                .text("Probability Density");

            // Legend
            const legend = svg.append("g")
                .attr("transform", `translate(${width + 20}, 20)`);

            legend.append("line")
                .attr("x1", 0)
                .attr("x2", 30)
                .attr("y1", 0)
                .attr("y2", 0)
                .attr("stroke", "#f39c12")
                .attr("stroke-width", 3);

            legend.append("text")
                .attr("x", 40)
                .attr("y", 5)
                .attr("class", "legend")
                .text("p(x, y = 0) * v(x)");

            legend.append("line")
                .attr("x1", 0)
                .attr("x2", 30)
                .attr("y1", 30)
                .attr("y2", 30)
                .attr("stroke", "#3498db")
                .attr("stroke-width", 3);

            legend.append("text")
                .attr("x", 40)
                .attr("y", 35)
                .attr("class", "legend")
                .text("p(x, y = 1) * v(x)");

            // Interactive hover
            const focus = svg.append("g")
                .style("display", "none");

            focus.append("circle")
                .attr("r", 5)
                .attr("fill", "red");

            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .on("mousemove", mousemove)
                .on("mouseout", () => {
                    focus.style("display", "none");
                    tooltip.style("opacity", 0);
                });

            function mousemove(event) {
                const [mx] = d3.pointer(event);
                const x = xScale.invert(mx);
                
                const y1 = (1 / (std1 * Math.sqrt(2 * Math.PI))) * 
                           Math.exp(-0.5 * Math.pow((x - mean1) / std1, 2));
                const y2 = (1 / (std2 * Math.sqrt(2 * Math.PI))) * 
                           Math.exp(-0.5 * Math.pow((x - mean2) / std2, 2));
                
                focus.style("display", null);
                focus.attr("transform", `translate(${xScale(x)},${yScale(Math.max(y1, y2))})`);
                
                tooltip
                    .style("opacity", 1)
                    .html(`x: ${x.toFixed(2)}<br/>y₀: ${y1.toFixed(3)}<br/>y₁: ${y2.toFixed(3)}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 30) + "px");
            }
        }

        // ============================================
        // CHART 4: STACKED AREA FREQUENCY CHART
        // ============================================
        function createChart4() {
            const margin = {top: 40, right: 100, bottom: 60, left: 80};
            const width = 900 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const svg = d3.select("#chart4")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Generate sample data
            const years = d3.range(1980, 2024, 1);
            const categories = ["Set model", "Sequence model", "Vector model", "End-to-end"];
            const colors = ["#7cb342", "#ff8a65", "#9575cd", "#ec407a"];
            
            const data = years.map(year => {
                const point = {year};
                let multiplier = Math.exp((year - 1980) / 15);
                if (year > 2010) multiplier *= Math.exp((year - 2010) / 5);
                
                categories.forEach((cat, i) => {
                    const base = Math.random() * 0.3 + 0.1;
                    const trend = year < 2000 ? 0.1 : (year - 2000) * 0.05;
                    point[cat] = base * multiplier + trend + Math.random() * 0.5;
                });
                return point;
            });

            // Stack the data
            const stack = d3.stack()
                .keys(categories)
                .order(d3.stackOrderNone)
                .offset(d3.stackOffsetNone);

            const series = stack(data);

            // Scales
            const xScale = d3.scaleLinear()
                .domain([1980, 2023])
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(series, s => d3.max(s, d => d[1]))])
                .range([height, 0]);

            // Area generator
            const areaGenerator = d3.area()
                .x(d => xScale(d.data.year))
                .y0(d => yScale(d[0]))
                .y1(d => yScale(d[1]))
                .curve(d3.curveBasis);

            // Draw areas with transition
            series.forEach((s, i) => {
                svg.append("path")
                    .datum(s)
                    .attr("class", "area-fill")
                    .attr("fill", colors[i])
                    .attr("d", d3.area()
                        .x(d => xScale(d.data.year))
                        .y0(height)
                        .y1(height)
                        .curve(d3.curveBasis)
                    )
                    .transition()
                    .delay(i * 200)
                    .duration(1500)
                    .attr("d", areaGenerator);
            });

            // Axes
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).tickFormat(d3.format("d")))
                .style("font-size", "12px");

            svg.append("g")
                .call(d3.axisLeft(yScale))
                .style("font-size", "12px");

            // Labels
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + 45)
                .text("Year");

            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", `translate(-50,${height/2})rotate(-90)`)
                .text("Frequency");

            // Legend
            const legend = svg.append("g")
                .attr("transform", `translate(20, 20)`);

            categories.forEach((cat, i) => {
                const g = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`);

                g.append("rect")
                    .attr("width", 15)
                    .attr("height", 15)
                    .attr("fill", colors[i])
                    .attr("opacity", 0.7);

                g.append("text")
                    .attr("x", 20)
                    .attr("y", 12)
                    .attr("class", "legend")
                    .text(cat);
            });

            // Interactive highlight
            svg.append("line")
                .attr("class", "hover-line")
                .attr("y1", 0)
                .attr("y2", height)
                .attr("stroke", "#333")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3")
                .style("display", "none");

            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .on("mousemove", function(event) {
                    const [mx] = d3.pointer(event);
                    const year = Math.round(xScale.invert(mx));
                    
                    d3.select(".hover-line")
                        .style("display", null)
                        .attr("x1", xScale(year))
                        .attr("x2", xScale(year));
                    
                    const yearData = data.find(d => d.year === year);
                    if (yearData) {
                        let html = `<strong>${year}</strong><br/>`;
                        categories.forEach((cat, i) => {
                            html += `${cat}: ${yearData[cat].toFixed(1)}<br/>`;
                        });
                        
                        tooltip
                            .style("opacity", 1)
                            .html(html)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 50) + "px");
                    }
                })
                .on("mouseout", () => {
                    d3.select(".hover-line").style("display", "none");
                    tooltip.style("opacity", 0);
                });
        }

        // ============================================
        // CHART 9: TREE DIAGRAM (SKETCH)
        // ============================================
        function createChart9() {
            const margin = {top: 40, right: 120, bottom: 40, left: 120};
            const width = 900 - margin.left - margin.right;
            const height = 600 - margin.top - margin.bottom;

            const svg = d3.select("#chart9")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Tree data structure
            const treeData = {
                name: "Root",
                value: 100,
                children: [
                    {
                        name: "Branch A",
                        value: 60,
                        children: [
                            { name: "Leaf A1", value: 25 },
                            { name: "Leaf A2", value: 20 },
                            { name: "Leaf A3", value: 15 }
                        ]
                    },
                    {
                        name: "Branch B",
                        value: 40,
                        children: [
                            { name: "Leaf B1", value: 22 },
                            { name: "Leaf B2", value: 18 }
                        ]
                    }
                ]
            };

            // Create tree layout
            const treeLayout = d3.tree()
                .size([height, width]);

            const root = d3.hierarchy(treeData);
            treeLayout(root);

            // Create organic tree branches (curved paths)
            const linkGenerator = d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x);

            // Draw trunk (thicker base)
            svg.append("line")
                .attr("class", "tree-branch")
                .attr("x1", -30)
                .attr("y1", height / 2)
                .attr("x2", 0)
                .attr("y2", height / 2)
                .attr("stroke-width", 8)
                .attr("opacity", 0)
                .transition()
                .duration(800)
                .attr("opacity", 1);

            // Draw links (branches) with animation
            const links = svg.selectAll(".tree-link")
                .data(root.links())
                .enter()
                .append("path")
                .attr("class", "tree-link")
                .attr("d", d => {
                    const o = {x: d.source.x, y: d.source.y};
                    return linkGenerator({source: o, target: o});
                })
                .attr("opacity", 0);

            links.transition()
                .delay((d, i) => 800 + i * 200)
                .duration(600)
                .attr("d", linkGenerator)
                .attr("opacity", 1);

            // Draw nodes
            const nodes = svg.selectAll(".tree-node")
                .data(root.descendants())
                .enter()
                .append("g")
                .attr("class", "tree-node")
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .attr("opacity", 0);

            // Animate nodes appearance
            nodes.transition()
                .delay((d, i) => 1000 + i * 150)
                .duration(400)
                .attr("opacity", 1);

            // Add circles for nodes
            nodes.append("circle")
                .attr("r", d => d.children ? 8 : 6)
                .style("fill", d => {
                    if (!d.children) return "#4caf50"; // Leaf nodes green
                    if (d.depth === 0) return "#8b4513"; // Root brown
                    return "#ff9800"; // Branch nodes orange
                })
                .style("stroke", "#333")
                .style("stroke-width", 2);

            // Add labels
            nodes.append("text")
                .attr("dy", -15)
                .attr("text-anchor", "middle")
                .style("font-size", d => d.depth === 0 ? "14px" : "12px")
                .style("font-weight", d => d.depth === 0 ? "bold" : "normal")
                .text(d => d.data.name);

            // Add value labels
            nodes.append("text")
                .attr("dy", 25)
                .attr("text-anchor", "middle")
                .style("font-size", "10px")
                .style("fill", "#666")
                .text(d => `(${d.data.value})`);

            // Add decorative leaves for leaf nodes
            nodes.filter(d => !d.children)
                .each(function(d, i) {
                    const leafGroup = d3.select(this);
                    
                    // Add multiple small leaf shapes around leaf nodes
                    const leafAngles = [0, 60, 120, 180, 240, 300];
                    leafAngles.forEach((angle, idx) => {
                        leafGroup.append("ellipse")
                            .attr("class", "tree-leaf")
                            .attr("cx", 0)
                            .attr("cy", 0)
                            .attr("rx", 0)
                            .attr("ry", 0)
                            .attr("transform", `rotate(${angle})`)
                            .transition()
                            .delay(1500 + i * 100 + idx * 50)
                            .duration(400)
                            .attr("cx", 15 * Math.cos(angle * Math.PI / 180))
                            .attr("cy", 15 * Math.sin(angle * Math.PI / 180))
                            .attr("rx", 4)
                            .attr("ry", 8);
                    });
                });

            // Interaction: Click nodes to highlight path to root
            let selectedNode = null;
            
            nodes.on("click", function(event, d) {
                // Reset previous selection
                nodes.classed("selected", false);
                svg.selectAll(".highlight-path").remove();

                if (selectedNode === d) {
                    selectedNode = null;
                    return;
                }

                selectedNode = d;
                
                // Highlight path from clicked node to root
                let current = d;
                const pathNodes = [current];
                
                while (current.parent) {
                    pathNodes.push(current.parent);
                    current = current.parent;
                }

                // Highlight nodes in path
                nodes.filter(node => pathNodes.includes(node))
                    .classed("selected", true);

                // Draw highlighted path
                for (let i = 0; i < pathNodes.length - 1; i++) {
                    svg.append("path")
                        .attr("class", "highlight-path")
                        .attr("d", linkGenerator({
                            source: pathNodes[i],
                            target: pathNodes[i + 1]
                        }))
                        .attr("stroke", "#ff4444")
                        .attr("stroke-width", 4)
                        .attr("fill", "none")
                        .attr("opacity", 0)
                        .transition()
                        .duration(300)
                        .attr("opacity", 0.8);
                }

                tooltip
                    .style("opacity", 1)
                    .html(`<strong>${d.data.name}</strong><br/>Value: ${d.data.value}<br/>Depth: ${d.depth}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 30) + "px");
            });

            nodes.on("mouseover", function(event, d) {
                d3.select(this).select("circle")
                    .transition()
                    .duration(200)
                    .attr("r", d.children ? 12 : 10);

                if (selectedNode !== d) {
                    tooltip
                        .style("opacity", 1)
                        .html(`<strong>${d.data.name}</strong><br/>Value: ${d.data.value}<br/>Click to highlight path`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 30) + "px");
                }
            })
            .on("mouseout", function(event, d) {
                d3.select(this).select("circle")
                    .transition()
                    .duration(200)
                    .attr("r", d.children ? 8 : 6);

                if (selectedNode !== d) {
                    tooltip.style("opacity", 0);
                }
            });

            // Add a "Reset" button
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -10)
                .attr("text-anchor", "middle")
                .style("font-size", "11px")
                .style("fill", "#999")
                .style("font-style", "italic")
                .text("Click nodes to highlight path to root • Click again to reset");
        }

        // ============================================
        // CHART 3: OPTIMIZATION ROUTE
        // ============================================
        function createChart3() {
            const margin = {top: 40, right: 40, bottom: 40, left: 40};
            const width = 700 - margin.left - margin.right;
            const height = 600 - margin.top - margin.bottom;

            const svg = d3.select("#chart3")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Grid
            const gridSize = 40;
            for (let i = 0; i <= width / gridSize; i++) {
                svg.append("line")
                    .attr("class", "grid-line")
                    .attr("x1", i * gridSize)
                    .attr("x2", i * gridSize)
                    .attr("y1", 0)
                    .attr("y2", height);
            }
            for (let i = 0; i <= height / gridSize; i++) {
                svg.append("line")
                    .attr("class", "grid-line")
                    .attr("x1", 0)
                    .attr("x2", width)
                    .attr("y1", i * gridSize)
                    .attr("y2", i * gridSize);
            }

            // Define optimization path (gradient descent-like)
            const pathPoints = [
                {x: 300, y: 150},
                {x: 320, y: 200},
                {x: 310, y: 260},
                {x: 280, y: 320},
                {x: 240, y: 380},
                {x: 200, y: 420},
                {x: 170, y: 450},
                {x: 150, y: 470},
                {x: 140, y: 480}
            ];

            // Draw contour lines (representing loss landscape)
            const contours = [
                {cx: 400, cy: 200, rx: 180, ry: 120, rotation: 45},
                {cx: 380, cy: 220, rx: 140, ry: 90, rotation: 45},
                {cx: 360, cy: 240, rx: 100, ry: 60, rotation: 45},
                {cx: 340, cy: 260, rx: 60, ry: 40, rotation: 45}
            ];

            contours.forEach((c, i) => {
                svg.append("ellipse")
                    .attr("cx", c.cx)
                    .attr("cy", c.cy)
                    .attr("rx", c.rx)
                    .attr("ry", c.ry)
                    .attr("transform", `rotate(${c.rotation}, ${c.cx}, ${c.cy})`)
                    .attr("class", "contour")
                    .attr("stroke", "#b0bec5")
                    .attr("fill", "none")
                    .attr("opacity", 0)
                    .transition()
                    .delay(i * 200)
                    .duration(800)
                    .attr("opacity", 0.6);
            });

            // Shaded regions
            svg.append("path")
                .attr("d", `M 250 100 L 380 280 L 340 320 L 210 140 Z`)
                .attr("fill", "#bbdefb")
                .attr("opacity", 0)
                .transition()
                .delay(1000)
                .duration(500)
                .attr("opacity", 0.3);

            svg.append("path")
                .attr("d", `M 380 280 L 520 460 L 480 500 L 340 320 Z`)
                .attr("fill", "#ffccbc")
                .attr("opacity", 0)
                .transition()
                .delay(1200)
                .duration(500)
                .attr("opacity", 0.3);

            // Labels on regions
            svg.append("text")
                .attr("x", 280)
                .attr("y", 200)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-style", "italic")
                .attr("fill", "#1976d2")
                .text("covered space")
                .attr("opacity", 0)
                .transition()
                .delay(1500)
                .duration(500)
                .attr("opacity", 0.8);

            svg.append("text")
                .attr("x", 420)
                .attr("y", 390)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-style", "italic")
                .attr("fill", "#d84315")
                .text("no coverage")
                .attr("opacity", 0)
                .transition()
                .delay(1700)
                .duration(500)
                .attr("opacity", 0.8);

            // "random start" label
            svg.append("text")
                .attr("x", 300)
                .attr("y", 130)
                .attr("text-anchor", "middle")
                .attr("font-size", "13px")
                .attr("font-style", "italic")
                .text("random start")
                .attr("opacity", 0)
                .transition()
                .delay(500)
                .duration(500)
                .attr("opacity", 1);

            // Draw path with animation
            const lineGenerator = d3.line()
                .x(d => d.x)
                .y(d => d.y)
                .curve(d3.curveCatmullRom);

            const path = svg.append("path")
                .datum(pathPoints)
                .attr("class", "optimization-path")
                .attr("d", lineGenerator)
                .attr("stroke-dasharray", function() {
                    return this.getTotalLength();
                })
                .attr("stroke-dashoffset", function() {
                    return this.getTotalLength();
                })
                .transition()
                .delay(2000)
                .duration(3000)
                .ease(d3.easeLinear)
                .attr("stroke-dashoffset", 0);

            // Add arrows along path
            pathPoints.forEach((point, i) => {
                if (i < pathPoints.length - 1) {
                    const next = pathPoints[i + 1];
                    const angle = Math.atan2(next.y - point.y, next.x - point.x);
                    
                    svg.append("path")
                        .attr("d", "M-5,-5 L5,0 L-5,5 Z")
                        .attr("fill", "#333")
                        .attr("transform", `translate(${(point.x + next.x) / 2}, ${(point.y + next.y) / 2}) rotate(${angle * 180 / Math.PI})`)
                        .attr("opacity", 0)
                        .transition()
                        .delay(2000 + i * 300)
                        .duration(300)
                        .attr("opacity", 0.7);
                }
            });

            // Points x and x'
            svg.append("rect")
                .attr("x", 450 - 8)
                .attr("y", 250 - 8)
                .attr("width", 16)
                .attr("height", 16)
                .attr("fill", "#2196f3")
                .attr("opacity", 0)
                .transition()
                .delay(2500)
                .duration(500)
                .attr("opacity", 1);

            svg.append("text")
                .attr("x", 450)
                .attr("y", 235)
                .attr("text-anchor", "middle")
                .attr("font-size", "18px")
                .attr("font-style", "italic")
                .text("x")
                .attr("opacity", 0)
                .transition()
                .delay(2500)
                .duration(500)
                .attr("opacity", 1);

            svg.append("rect")
                .attr("x", 540 - 8)
                .attr("y", 250 - 8)
                .attr("width", 16)
                .attr("height", 16)
                .attr("fill", "#f44336")
                .attr("opacity", 0)
                .transition()
                .delay(3000)
                .duration(500)
                .attr("opacity", 1);

            svg.append("text")
                .attr("x", 540)
                .attr("y", 235)
                .attr("text-anchor", "middle")
                .attr("font-size", "18px")
                .attr("font-style", "italic")
                .text("x'")
                .attr("opacity", 0)
                .transition()
                .delay(3000)
                .duration(500)
                .attr("opacity", 1);

            // Interactive: click to restart animation
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .on("click", function() {
                    // Restart path animation
                    d3.select(".optimization-path")
                        .attr("stroke-dashoffset", function() {
                            return this.getTotalLength();
                        })
                        .transition()
                        .duration(3000)
                        .ease(d3.easeLinear)
                        .attr("stroke-dashoffset", 0);
                });
        }

        // Create all charts
        createChart1();
        createChart11();
        createChart4();
        createChart3();
        createChart9();
    </script>
</body>
</html>
